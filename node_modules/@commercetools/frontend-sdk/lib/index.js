"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ActionError: () => ActionError,
  CookieHandler: () => CookieHandler,
  Event: () => Event,
  Extension: () => Extension,
  FetchError: () => FetchError,
  Integration: () => Integration,
  PageError: () => PageError,
  SDK: () => SDK,
  rememberMeCookie: () => rememberMeCookie,
  rememberMeCookieAsync: () => rememberMeCookieAsync,
  serverSession: () => serverSession
});
module.exports = __toCommonJS(src_exports);

// src/library/oldCookieHandler.ts
var import_cookie = require("cookie");
var CookieHandlerSync = class {
  static isClientSide() {
    return typeof window !== "undefined";
  }
  static stringify(value = "") {
    try {
      const result = JSON.stringify(value);
      return /^[\{\[]/.test(result) ? result : value;
    } catch (e) {
      return value;
    }
  }
  static decode(str) {
    return str ? str.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent) : str;
  }
  static processValue(value) {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      case "undefined":
        return void 0;
      case "null":
        return null;
      default:
        return value;
    }
  }
  static getCookies(options) {
    let req;
    if (options) {
      req = options.req;
    }
    if (!this.isClientSide()) {
      if (req?.cookies) {
        return req.cookies;
      }
      if (req?.headers?.cookie) {
        return (0, import_cookie.parse)(req.headers.cookie);
      }
      return {};
    }
    const _cookies = {};
    const documentCookies = document.cookie ? document.cookie.split("; ") : [];
    for (let i = 0, len = documentCookies.length; i < len; i++) {
      const cookieParts = documentCookies[i].split("=");
      const _cookie = cookieParts.slice(1).join("=");
      const name = cookieParts[0];
      _cookies[name] = _cookie;
    }
    return _cookies;
  }
  static hasCookie(key, options) {
    if (!key) {
      return false;
    }
    const cookie = this.getCookies(options);
    return cookie.hasOwnProperty(key);
  }
  static setCookie(key, data, options) {
    let _cookieOptions;
    let _req;
    let _res;
    if (options) {
      const { req, res, ..._options } = options;
      _req = req;
      _res = res;
      _cookieOptions = _options;
    }
    const cookieStr = (0, import_cookie.serialize)(key, this.stringify(data), {
      path: "/",
      ..._cookieOptions
    });
    if (!this.isClientSide()) {
      if (_res && _req) {
        let currentCookies = _res.getHeader("Set-Cookie");
        if (!Array.isArray(currentCookies)) {
          currentCookies = !currentCookies ? [] : [String(currentCookies)];
        }
        _res.setHeader("Set-Cookie", currentCookies.concat(cookieStr));
        if (_req && _req.cookies) {
          const _cookies = _req.cookies;
          data === "" ? delete _cookies[key] : _cookies[key] = this.stringify(data);
        }
        if (_req && _req.headers && _req.headers.cookie) {
          const _cookies = (0, import_cookie.parse)(_req.headers.cookie);
          data === "" ? delete _cookies[key] : _cookies[key] = this.stringify(data);
          _req.headers.cookie = Object.entries(_cookies).reduce(
            (accum, item) => {
              return accum.concat(`${item[0]}=${item[1]};`);
            },
            ""
          );
        }
      }
    } else {
      document.cookie = cookieStr;
    }
  }
  static getCookie(key, options) {
    const _cookies = this.getCookies(options);
    const value = _cookies[key];
    if (value === void 0) {
      return void 0;
    }
    return this.processValue(this.decode(value));
  }
  static deleteCookie(key, options) {
    this.setCookie(key, "", { ...options, maxAge: -1 });
  }
};

// src/constants/rememberMeCookieKey.ts
var REMEMBER_ME_COOKIE_KEY = "__rememberMe";

// src/helpers/oldCookieManagement.ts
var rememberMeCookie = {
  /**
   * @deprecated Use rememberMeCookieAsync.get instead. Gets the remember me cookie, is not compatible with optional cookieHandlingOverride passed in SDK.configure.
   *
   * @param {ServerOptions} [serverOptions] - An optional {@link ServerOptions} object containing the res and req objects for ServerResponse and IncomingMessage with cookies respectively. Required for server-side rendering session management.
   *
   * @returns {boolean} A boolean indicating whether or not the user is to be remembered.
   */
  get: function(serverOptions) {
    if (CookieHandlerSync.getCookie(REMEMBER_ME_COOKIE_KEY, serverOptions)) {
      return true;
    }
    return false;
  },
  /**
   * @deprecated Use rememberMeCookieAsync.get instead. Sets the remember me cookie, is not compatible with optional cookieHandlingOverride passed in SDK.configure.
   *
   * @param {boolean} rememberMe - The value in which to set the remember me cookie.
   * @param {ServerOptions} [serverOptions] - An optional {@link ServerOptions} object containing the res and req objects for ServerResponse and IncomingMessage with cookies respectively. Required for server-side rendering session management.
   *
   * @returns {void} Void.
   */
  set: function(rememberMe, serverOptions) {
    if (rememberMe) {
      return CookieHandlerSync.setCookie(
        REMEMBER_ME_COOKIE_KEY,
        "1",
        serverOptions
      );
    } else {
      this.remove();
    }
  },
  /**
   * @deprecated Use rememberMeCookieAsync.remove instead. Removes the remember me cookie, is not compatible with optional cookieHandlingOverride passed in SDK.configure.
   *
   * @param {ServerOptions} [serverOptions] - An optional {@link ServerOptions} object containing the res and req objects for ServerResponse and IncomingMessage with cookies respectively. Required for server-side rendering session management.
   *
   * @returns {void} Void.
   */
  remove: function(serverOptions) {
    return CookieHandlerSync.deleteCookie(
      REMEMBER_ME_COOKIE_KEY,
      serverOptions
    );
  }
};
var serverSession = {
  /**
   * @deprecated Pass the {@link IncomingMessage} and {@link ServerResponse} to cookie helpers directly instead. Used to retieve the session string, is not compatible with optional cookieHandlingOverride passed in SDK.configure.
   *
   * @param {IncomingMessage} req - The incoming message created by the server.
   * @param {ServerResponse} res - The server response object created by the server.
   */
  get: function(req, res) {
    return CookieHandlerSync.getCookie("frontastic-session", {
      req,
      res
    })?.toString();
  }
};

// src/constants/defaultSessionLifetime.ts
var DEFAULT_SESSION_LIFETIME = 7776e6;

// src/constants/sdkNotConfiguredErrorMessage.ts
var SDK_NOT_CONFIGURED_ERROR_MESSAGE = "The SDK has not been configured. Please call .configure on the base SDK before you call any other methods";

// src/library/DependencyContainer.ts
var DependencyContainer = class {
  hasBeenConfigured;
  _cookieHandler;
  constructor() {
    this.hasBeenConfigured = false;
  }
  get cookieHandler() {
    return this._cookieHandler;
  }
  set cookieHandler(cookierHandler) {
    this._cookieHandler = cookierHandler;
  }
  configure(cookieHandler) {
    this.hasBeenConfigured = true;
    this.cookieHandler = cookieHandler;
  }
  throwIfDINotConfigured = () => {
    if (!this.hasBeenConfigured) {
      throw new Error(SDK_NOT_CONFIGURED_ERROR_MESSAGE);
    }
  };
};
var Wrapper = class {
  dependencyContainer;
  constructor() {
    this.dependencyContainer = new DependencyContainer();
  }
  getDependencyContainer = () => this.dependencyContainer;
};
var wrapper = new Wrapper();
var dependencyContainer = wrapper.getDependencyContainer;

// src/helpers/cookieManagement.ts
var rememberMeCookieAsync = {
  /**
   * Gets the remember me cookie.
   *
   * @param {ServerOptions} [serverOptions] - An optional {@link ServerOptions} object containing the res and req objects for ServerResponse and IncomingMessage with cookies respectively. Required for server-side rendering session management.
   *
   * @returns {Promise<boolean>} A boolean indicating whether or not the user is to be remembered.
   */
  get: async function(serverOptions) {
    dependencyContainer().throwIfDINotConfigured();
    const rememberMe = await dependencyContainer().cookieHandler.getCookie(
      REMEMBER_ME_COOKIE_KEY,
      serverOptions
    );
    return !!rememberMe;
  },
  /**
   * Sets the remember me cookie.
   *
   * @param {boolean} rememberMe - The value in which to set the remember me cookie.
   * @param {ServerOptions} [serverOptions] - An optional {@link ServerOptions} object containing the res and req objects for ServerResponse and IncomingMessage with cookies respectively. Required for server-side rendering session management.
   *
   * @returns {Promise<void>} Void.
   */
  set: async function(rememberMe, serverOptions) {
    dependencyContainer().throwIfDINotConfigured();
    if (rememberMe) {
      await dependencyContainer().cookieHandler.setCookie(
        REMEMBER_ME_COOKIE_KEY,
        "1",
        serverOptions
      );
    } else {
      await this.remove();
    }
  },
  /**
   * Removes the remember me cookie.
   *
   * @param {ServerOptions} [serverOptions] - An optional {@link ServerOptions} object containing the res and req objects for ServerResponse and IncomingMessage with cookies respectively. Required for server-side rendering session management.
   *
   * @returns {Promise<void>} Void.
   */
  remove: async function(serverOptions) {
    dependencyContainer().throwIfDINotConfigured();
    await dependencyContainer().cookieHandler.deleteCookie(
      REMEMBER_ME_COOKIE_KEY,
      serverOptions
    );
  }
};

// src/library/Extension.ts
var Extension = class {
  /**
   * The sdk instance passed and assigned in the constructor.
   */
  sdk;
  /**
   * Contructor.
   *
   * @param {SDK} sdk - The singleton sdk instance created within your project.
   */
  constructor(sdk) {
    this.sdk = sdk;
  }
};

// src/library/Integration.ts
var Integration = class {
  /**
   * The sdk instance passed and assigned in the constructor.
   */
  sdk;
  /**
   * Contructor.
   *
   * @param {SDK} sdk - The singleton sdk instance created within your project.
   */
  constructor(sdk) {
    this.sdk = sdk;
  }
};

// src/library/FetchError.ts
var FetchError = class extends Error {
  /**
   * The message associated with the error.
   */
  message;
  /**
   * Constructor.
   *
   * @param {string | Error} error - The error message or object detected.
   */
  constructor(error) {
    super();
    if (typeof error === "string") {
      this.message = error;
    } else {
      Object.keys(error).forEach((key) => {
        this[key] = error[key];
      });
    }
  }
};

// src/helpers/fetcher.ts
var fetcher = async (url, options, serverOptions, sessionLifetime) => {
  dependencyContainer().throwIfDINotConfigured();
  let sessionCookie = await dependencyContainer().cookieHandler.getCookie(
    "frontastic-session",
    serverOptions
  );
  sessionCookie = sessionCookie ?? "";
  const incomingHeaders = serverOptions?.req ? { ...serverOptions.req.headers } : {};
  delete incomingHeaders["host"];
  delete incomingHeaders["cookie"];
  options.headers = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "X-Frontastic-Access-Token": "APIKEY",
    ...options.headers || {},
    ...sessionCookie ? { "Frontastic-Session": sessionCookie } : {},
    ...incomingHeaders
  };
  const response = await fetch(url, options);
  if (response.ok && response.headers.has("Frontastic-Session")) {
    let rememberMe = await rememberMeCookieAsync.get();
    let expiryDate;
    if (rememberMe) {
      expiryDate = new Date(
        Date.now() + (sessionLifetime ?? DEFAULT_SESSION_LIFETIME)
      );
    }
    await dependencyContainer().cookieHandler.setCookie(
      "frontastic-session",
      response.headers.get("Frontastic-Session"),
      { expires: expiryDate, ...serverOptions ?? {} }
    );
  }
  if (response.ok) {
    return response.json();
  }
  let error;
  try {
    error = await response.clone().json();
  } catch (e) {
    error = await response.text();
  }
  return new FetchError(error);
};

// src/library/Queue.ts
var Queue = class {
  #queue = [];
  #promisePending = false;
  #stopped = false;
  add(promise) {
    return new Promise((resolve, reject) => {
      this.#queue.push({
        promise,
        resolve,
        reject
      });
      this.#handle();
    });
  }
  stop() {
    this.#stopped = true;
  }
  restart() {
    this.#stopped = false;
    this.#handle();
  }
  #handle() {
    if (this.#promisePending || this.#stopped) {
      return;
    }
    const item = this.#queue.shift();
    if (!item) {
      return;
    }
    try {
      this.#promisePending = true;
      item.promise().then((value) => this.#resolve(() => item.resolve(value))).catch((err) => this.#resolve(() => item.reject(err)));
    } catch (err) {
      this.#resolve(() => item.reject(err));
    }
  }
  #resolve(callback) {
    this.#promisePending = false;
    callback();
    this.#handle();
  }
};

// src/library/Event.ts
var Event = class {
  /**
   * The name of the event, will match the key of the specific event.
   */
  eventName;
  /**
   * The data associated with the event, will match the value of the specific event and be the parameter supplied to the event handler.
   */
  data;
  isDefaultPrevented;
  isCancelled;
  isPropagationStopped;
  /**
   * Contructor.
   *
   * @param {EventName} options.eventName - The name of the event being created, will match the key of the specific event.
   * @param {EventData} options.data - The data associated with the event being created, will match the value of the specific event and be the parameter supplied to the event handler.
   */
  constructor(options) {
    this.eventName = options.eventName;
    this.data = options.data;
    this.isCancelled = false;
    this.isDefaultPrevented = false;
    this.isPropagationStopped = false;
  }
  preventDefault() {
    this.isDefaultPrevented = true;
  }
  cancel() {
    this.isCancelled = true;
  }
  stopPropagation() {
    this.isPropagationStopped = true;
  }
};

// src/library/EventManager.ts
var EventManager = class {
  eventHandlers;
  constructor() {
    this.eventHandlers = {};
  }
  getEventHandlers(eventName) {
    let eventHandlers = this.eventHandlers[eventName];
    if (eventHandlers === void 0) {
      eventHandlers = [];
      this.eventHandlers[eventName] = eventHandlers;
    }
    return eventHandlers;
  }
  /**
   * Adds an event handler for a pre-defined event.
   *
   * @param {EventName} eventName - The name of the event, will match the key of the specific event.
   * @param {(event: Event<EventName, Events[EventName]>) => void} handler - The handler function to be called when the event is triggered.
   */
  on(eventName, handler) {
    let eventHandlers = this.getEventHandlers(eventName);
    eventHandlers.push(handler);
  }
  /**
   * Removes an event handler for a pre-defined event.
   *
   * @param {EventName} eventName - The name of the event, will match the key of the specific event.
   * @param {(event: Event<EventName, Events[EventName]>) => void} handler - The handler function instance to be removed.
   */
  off(eventName, handler) {
    let eventHandlers = this.getEventHandlers(eventName);
    eventHandlers.splice(eventHandlers.indexOf(handler), 1);
  }
  /**
   * Triggers a pre-defined event.
   *
   * @param {Event<EventName, Events[EventName]>} event - The event to be triggered.
   */
  trigger(event) {
    for (let handler of this.getEventHandlers(event.eventName)) {
      handler(event);
    }
  }
};

// src/library/ActionError.ts
var ActionError = class extends FetchError {
  /**
   * The name of the failed action.
   */
  actionName;
  /**
   * Constructor.
   *
   * @param {string} actionName - The name of the failed action.
   * @param {FetchError} error - The error returned from the internal fetcher.
   */
  constructor(actionName, error) {
    super(error);
    this.actionName = actionName;
  }
};

// src/library/PageError.ts
var PageError = class extends FetchError {
  /**
   * The path requested during the failed page API call.
   */
  path;
  /**
   * Constructor.
   *
   * @param {string} path - The path requested during the failed page API call.
   * @param {FetchError} error - The error returned from the internal fetcher.
   */
  constructor(path, error) {
    super(error);
    this.path = path;
  }
};

// src/helpers/queryStringHelpers.ts
var generateQueryString = function(query) {
  const params = new URLSearchParams();
  Object.keys(query).forEach((key) => {
    if (query[key] !== void 0) {
      params.set(key, query[key].toString());
    }
  });
  return `?${params.toString()}`;
};

// src/library/CookieHandler.ts
var import_cookie2 = require("cookie");
var CookieHandler = class {
  isClientSide() {
    return typeof window !== "undefined";
  }
  stringify(value = "") {
    try {
      const result = JSON.stringify(value);
      return /^[\{\[]/.test(result) ? result : value;
    } catch (e) {
      return value;
    }
  }
  decode(str) {
    return str ? str.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent) : str;
  }
  processValue(value) {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      case "undefined":
        return void 0;
      case "null":
        return null;
      default:
        return value;
    }
  }
  async getCookies(options) {
    let req;
    if (options) {
      req = options.req;
    }
    if (!this.isClientSide()) {
      if (req?.cookies) {
        return req.cookies;
      }
      if (req?.headers?.cookie) {
        return (0, import_cookie2.parse)(req.headers.cookie);
      }
      return {};
    }
    const _cookies = {};
    const documentCookies = document.cookie ? document.cookie.split("; ") : [];
    for (let i = 0, len = documentCookies.length; i < len; i++) {
      const cookieParts = documentCookies[i].split("=");
      const _cookie = cookieParts.slice(1).join("=");
      const name = cookieParts[0];
      _cookies[name] = _cookie;
    }
    return _cookies;
  }
  async hasCookie(key, options) {
    if (!key) {
      return false;
    }
    const cookie = await this.getCookies(options);
    return cookie.hasOwnProperty(key);
  }
  async setCookie(key, data, options) {
    let _cookieOptions;
    let _req;
    let _res;
    if (options) {
      const { req, res, ..._options } = options;
      _req = req;
      _res = res;
      _cookieOptions = _options;
    }
    const cookieStr = (0, import_cookie2.serialize)(key, this.stringify(data), {
      path: "/",
      ..._cookieOptions
    });
    if (!this.isClientSide()) {
      if (_res && _req) {
        let currentCookies = _res.getHeader("Set-Cookie");
        if (!Array.isArray(currentCookies)) {
          currentCookies = !currentCookies ? [] : [String(currentCookies)];
        }
        _res.setHeader("Set-Cookie", currentCookies.concat(cookieStr));
        if (_req && _req.cookies) {
          const _cookies = _req.cookies;
          data === "" ? delete _cookies[key] : _cookies[key] = this.stringify(data);
        }
        if (_req && _req.headers && _req.headers.cookie) {
          const _cookies = (0, import_cookie2.parse)(_req.headers.cookie);
          data === "" ? delete _cookies[key] : _cookies[key] = this.stringify(data);
          _req.headers.cookie = Object.entries(_cookies).reduce(
            (accum, item) => {
              return accum.concat(`${item[0]}=${item[1]};`);
            },
            ""
          );
        }
      }
    } else {
      document.cookie = cookieStr;
    }
  }
  async getCookie(key, options) {
    const _cookies = await this.getCookies(options);
    const value = _cookies[key];
    if (value === void 0) {
      return void 0;
    }
    return this.processValue(this.decode(value));
  }
  async deleteCookie(key, options) {
    this.setCookie(key, "", { ...options, maxAge: -1 });
  }
};

// src/library/SDK.ts
var SDK = class extends EventManager {
  #hasBeenConfigured;
  #endpoint;
  #locale;
  #currency;
  #useCurrencyInLocale;
  #extensionVersion;
  #actionQueue;
  #sessionLifetime;
  set endpoint(url) {
    url = this.#normaliseUrl(url);
    if (url.indexOf("http") === -1) {
      url = `https://${url}`;
      console.warn(
        `Protocol not supplied to endpoint, defaulting to https - ${url}`
      );
    }
    this.#endpoint = url.split("/frontastic")[0];
  }
  /**
   * The full url endpoint to be called, to be set within the {@link configure} method.
   */
  get endpoint() {
    return this.#endpoint;
  }
  set locale(locale) {
    this.#locale = new Intl.Locale(locale);
  }
  /**
   * The string representing the combination of the ISO 639-1 language and ISO 3166-1 country code, to be set within the {@link configure} method.
   */
  get locale() {
    return this.#locale.baseName;
  }
  /**
   * @deprecated The string representing the locale in the posix format to be used internally.
   */
  get posixLocale() {
    const apiFormattedLocale = this.locale.slice(0, 5).replace("-", "_");
    if (this.#useCurrencyInLocale) {
      return `${apiFormattedLocale}@${this.currency}`;
    } else {
      return apiFormattedLocale;
    }
  }
  /**
   * The string representing the locale formatted to be used when communicating with the backend.
   */
  get apiHubLocale() {
    const apiFormattedLocale = this.locale.replace("-", "_");
    if (this.#useCurrencyInLocale) {
      return `${apiFormattedLocale}@${this.currency}`;
    } else {
      return apiFormattedLocale;
    }
  }
  set currency(currency) {
    this.#currency = currency;
  }
  /**
   * The string representing the ISO 3-Letter Currency Code, to be set within the {@link configure} method.
   */
  get currency() {
    return this.#currency;
  }
  constructor() {
    super();
    this.#hasBeenConfigured = false;
    this.#actionQueue = new Queue();
  }
  #throwIfNotConfigured() {
    if (!this.#hasBeenConfigured) {
      throw new Error(SDK_NOT_CONFIGURED_ERROR_MESSAGE);
    }
  }
  #normaliseUrl = (url) => url.split("//").reduce((previous, current) => {
    if (current === "http:" || current === "https:") {
      return current += "/";
    }
    return `${previous}/${current}`;
  }, "");
  /**
   * The method that must be called prior to any other methods to configure the connection to the backend. An error is throw if not called prior.
   *
   * @param {string} config.locale - A string representing the combination of the ISO 639-1 language and ISO 3166-1 country code. For example "en-DE" or "en_DE".
   * @param {string} config.currency - A string representing the ISO 3-Letter Currency Code, for example EUR.
   * @param {string} config.endpoint - A string representing the full URL of the endpoint to be called.
   * @param {boolean} [config.useCurrencyInLocale=false] - An optional boolean, default false. To be set to true if currency is required in config.locale, for example en-GB@EUR.
   * @param {string} [config.extensionVersion=""] - An optional string required for multitenancy projects, stored in the environment variable process.env.NEXT_PUBLIC_EXT_BUILD_ID to specify the extension version in which to connect.
   * @param {string} [config.sessionLifetime=7776000000] - An optional number of milliseconds in which to persist the session lifeTime, to override the {@link DEFAULT_SESSION_LIFETIME} of 3 months.
   * @param {CookieManager} [config.cookieHandlingOverride] - An optional cookie manager interface that contains all the cookie handling methods.
   *
   * @returns {void} Void.
   */
  configure(config) {
    dependencyContainer().configure(
      config.cookieHandlingOverride ?? new CookieHandler()
    );
    this.endpoint = config.endpoint;
    this.configureLocale(config);
    this.#useCurrencyInLocale = config.useCurrencyInLocale ?? false;
    this.#extensionVersion = config.extensionVersion ?? "";
    this.#sessionLifetime = config.sessionLifetime ?? DEFAULT_SESSION_LIFETIME;
    this.#hasBeenConfigured = true;
  }
  /**
   * The method called to standardise the locale and currency inputs.
   *
   * @param {string} config.locale - A string representing the combination of the ISO 639-1 language and ISO 3166-1 country code. For example en-GB or en_GB.
   * @param {string} config.currency - A string representing the ISO 3-Letter Currency Code, for example EUR.
   *
   * @returns {void} Void.
   */
  configureLocale(config) {
    const [locale, currency] = config.locale.split("@");
    if (currency) {
      this.currency = currency;
    }
    if (config.currency) {
      this.currency = config.currency;
    }
    this.locale = locale.replace(/_/g, "-");
  }
  #triggerError(error) {
    this.trigger(
      // @ts-ignore
      new Event({
        eventName: "errorCaught",
        data: {
          error
        }
      })
    );
  }
  #handleError(options) {
    let error;
    if (options.error instanceof FetchError) {
      error = options.error;
    } else {
      error = new FetchError(options.error);
    }
    this.#triggerError(
      options.type === "ActionError" ? new ActionError(options.actionName, error) : new PageError(options.path, error)
    );
    return { isError: true, error };
  }
  #getDefaultAPIHeaders() {
    return {
      "Frontastic-Locale": this.apiHubLocale,
      "Frontastic-Currency": this.currency,
      ...this.#extensionVersion ? {
        "Commercetools-Frontend-Extension-Version": this.#extensionVersion
      } : {}
    };
  }
  /**
   * The method used to call extension actions.
   *
   * @param {string} options.actionName - The name of the action corresponding to the location of the extension, for example "product/getProduct".
   * @param {unknown} [options.payload] - An optional key, value pair object payload to be serialised into the body of the request.
   * @param {Object.<string, number, boolean, string[], number[], boolean[]>} [options.query] - An optional key, value pair object to be serialised into the url query.
   * @param {Object} [options.serverOptions] - An optional object containing the res and req objects for ServerResponse and IncomingMessage with cookies respectively. Required for server-side rendering session management.
   *
   * @returns {PromiseLike<Object>} An object with a boolean isError property, and either an error or data property for true and false respectively. Type of data will match generic argument supplied to method.
   */
  async callAction(options) {
    this.#throwIfNotConfigured();
    options.payload = options.payload ?? {};
    const params = options.query ? generateQueryString(options.query) : "";
    const fetcherOptions = {
      method: "POST",
      body: JSON.stringify(options.payload),
      headers: this.#getDefaultAPIHeaders()
    };
    let result;
    try {
      result = await this.#actionQueue.add(
        () => {
          return fetcher(
            this.#normaliseUrl(
              `${this.#endpoint}/frontastic/action/${options.actionName}${params}`
            ),
            fetcherOptions,
            options.serverOptions,
            this.#sessionLifetime
          );
        }
      );
    } catch (error) {
      return this.#handleError({
        type: "ActionError",
        error,
        actionName: options.actionName
      });
    }
    if (result instanceof Error) {
      return this.#handleError({
        type: "ActionError",
        error: result.toString(),
        actionName: options.actionName
      });
    }
    return { isError: false, data: result };
  }
  /**
   * The domain to call page methods on the API hub.
   */
  page = {
    getPage: async (options) => {
      this.#throwIfNotConfigured();
      const params = options.query ? generateQueryString(options.query) : "";
      const fetcherOptions = {
        method: "POST",
        headers: {
          "Frontastic-Path": options.path,
          ...this.#getDefaultAPIHeaders()
        }
      };
      let result;
      try {
        result = await fetcher(
          this.#normaliseUrl(
            `${this.#endpoint}/frontastic/page${params}`
          ),
          fetcherOptions,
          options.serverOptions,
          this.#sessionLifetime
        );
      } catch (error) {
        return this.#handleError({
          type: "PageError",
          error,
          path: options.path
        });
      }
      if (result instanceof Error) {
        return this.#handleError({
          type: "PageError",
          error: result.toString(),
          path: options.path
        });
      }
      return { isError: false, data: result };
    },
    getPreview: async (options) => {
      this.#throwIfNotConfigured();
      const fetcherOptions = {
        method: "POST",
        headers: this.#getDefaultAPIHeaders()
      };
      let result;
      const path = `/preview?previewId=${options.previewId}&locale=${this.apiHubLocale}`;
      try {
        result = await fetcher(
          this.#normaliseUrl(`${this.#endpoint}/frontastic${path}`),
          fetcherOptions,
          options.serverOptions,
          this.#sessionLifetime
        );
      } catch (error) {
        return this.#handleError({
          type: "PageError",
          error,
          path
        });
      }
      if (result instanceof Error) {
        return this.#handleError({
          type: "PageError",
          error: result.toString(),
          path
        });
      }
      return { isError: false, data: result };
    },
    getPages: async (options = {
      depth: 16,
      types: "static"
    }) => {
      this.#throwIfNotConfigured();
      options.depth = options.depth ?? 16;
      options.types = options.types ?? "static";
      const fetcherOptions = {
        method: "POST",
        headers: this.#getDefaultAPIHeaders()
      };
      let result;
      const path = `/structure?locale=${this.apiHubLocale}${options.path ? `&path=${options.path}` : ""}&depth=${options.depth}`;
      try {
        result = await fetcher(
          this.#normaliseUrl(`${this.#endpoint}/frontastic${path}`),
          fetcherOptions,
          options.serverOptions,
          this.#sessionLifetime
        );
      } catch (error) {
        return this.#handleError({
          type: "PageError",
          error,
          path
        });
      }
      if (result instanceof Error) {
        return this.#handleError({
          type: "PageError",
          error: result.toString(),
          path
        });
      }
      return { isError: false, data: result };
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ActionError,
  CookieHandler,
  Event,
  Extension,
  FetchError,
  Integration,
  PageError,
  SDK,
  rememberMeCookie,
  rememberMeCookieAsync,
  serverSession
});
//# sourceMappingURL=index.js.map